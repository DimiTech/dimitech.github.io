---
layout: post
title:  "How to Become an Expert (Part 2)"
description: "What it Takes to Become an Expert Programmer (Part 2)"
tags: [Programming, Expert, Best Practices]

---

The purpose of this blog post is to help **intermediate** programmers get to
the next level in terms of their programming skill, productivity and hopefully
in life.

The goal is to become a Professional Software Developer - an Expert.

I will split this post into SOFT SKILLS and HARD SKILL" parts, but keep in
mind that they're both equally imporant.

# HARD SKILLS

## Become highly proficient in your main programming language

Another "common sense" point that is not so common in the real world, it's
actually **rare!**

Learn at least 90% of your programming language features, tools, the runtime
(how it executes), the ecosystem and the philosophy. Read **lots of books** in order
to find those which are the most valuable. If your language has **source code**
avialable - study it, get to know it really well. If it doesn't - **then why
are you using it !?**

Keep up to date with latest updates, news, books, conferences, podcasts, blogs,
best practices...

Simply put - **be an expert in your language!**

## Be familiar with different programming languages & ecosystems

There's a high chance that immersing yourself in a single programming language
ecosystem can't give you enough wisdom && perspective about programming.
Different programming language "communities" have different things that they
focus on and, to become well-rounded, you must expose yourself to many of them.

One example: (Today, in 2022) **JavaScript** programmers don't know much about
software architecture, design patterns & best practices in general because
the ecosystem isn't oriented around those. Contrary to that, **Java** programmers
have focused on design & best practices for over 20 years, but they are not
exposed to the beauty and writing efficiency of dynamically & weakly typed
programming languages for example. **Ruby** programmers have put extreme emphasis
on software testing & more efficent ways to write code for example (using Vim
|| Emacs). **Functional** programming paradigm && languages have their own
valuable perspectives to offer.

Of course, over the years, different ecosystems become influenced by each other
and features and paradigms get adopted across the languages. But I think it's
best to get this wisdom & perspective from the source - learn an OOP language,
then a functional one, then a systems language... there is lots of knowledge to
be gained by doing so.

## Learn low level programming

Take some time to learn **C**, **Data-Structures**, **Algorithms** etc...

Low level programming might not seem relevant at your current job, but not
knowing it will certainly hurt you at some point. You can introduce memory
leaks & inefficiencies no matter how abstract your programming environment is,
so it's good to develop an instinctual understanding of these things.

Also there is a inner sense of peace & fulfillment when you finally understand
how computer programming really works.

## Become an expert in software testing

Time and time again, I'm shocked by how little developers know about testing
their code. For me, tests are critical in order to have a bigger codebase that
is successful.

Developers are reluctant to learn testing because it's boring to them or what
not, but we're here to achieve a goal of bringing value to our users, not to
have fun and mess around. If testing is not enjoyable to you I'm sorry, but you
must learn it really well, there's no way around it.

I personally enjoy writing tests, especially because it protects my codebase
from bugs as the codebase grows over the years, and that removes almost all
anxiety that I might have about my software.

Testing will force you to write better quality code, because the code usually
has to be designed in a decoupled manner in order for it to even be testable.

Teseting is a huge topic and I don't want to go too deep into it - but for any
software professional **it is an essential skill.**

## You have to know UNIX based systems really well (GNU/Linux, BSD, MacOS...)

Most of the world's software runs on UNIX based operating systems, so knowing
them is simply a must.

Not knowing the UNIX philosophy and architecture, how to best work with
terminal emulators and so on, means that you don't really know how computers
work.

Graphical Operating Systems like Windows do very well in protecting the users
from the intricacies of the underlying operating system and it's mechanisms.
This is not where we want to be as programming professionals, we need to know
how things REALLY work.

Aside from that, majestic projects such as GNU/Linux help humanity instead of
hindering it. GNU/Linux based operating systems are mostly free of charge, with
source code completely available to anyone.

This means that even the poorest & unluckiest of us have some sort of a chance
to learn computing without paying huge corporations for a licence (or resorting
to piracy). Also we can learn from the actual source code, which is not the
case with propriatery operating systems. GNU/Linux systems (usually) respect the
users freedom, because you can actually see the source code that (when
compiled) you're running on your computer - it's completely transparent.
Proprietary operating systems (usually) exploit the users instead - invading
their privacy, limiting their computing freedoms, wasting time, showing ads etc.

Also this is a HUGE topic, but the essence is - **know your UNIX**.

## DevOps & Infrastructure

This ties to the previous point, because in order to understand computer
infrastructure - you must know GNU/Linux because most infrastructure is based
around it.

Most servers run GNU/Linux or BSD because it's the most efficient, powerful and
reliable system for the job.

Infrastructure plays a huge role in today's world, where most software is
composed of different infrastructure pieces (services) that work together in
concert.

Having a good knowledge about servers, services & cloud infrastructure is a
must for any software professional.

With the rise of DevOps, every professional developer needs to know how to work
with infrastructure really well. You need to be very familiar with at least a
single cloud provider and need to know && keep up to date with recent
developments and best practices. As a developer, you can't know every single
service that a cloud provider has to offer, but you need to know the basics at
the very least.

You also need to be a student of DevOps and think about how you can deliver
software in a most efficient way, in the shortest amount of time possible.

Another huge topic, but simply put: **DevOps & Infrastructure knowledge is a
must!**

## Conclusion: You must know everything!

No one can become and remain an expert in all aspects of software development
at once, but you must have at least a very good understanding of all of it.

Focus on a couple of main fields which you will dominate, and be at least very
good at the others.

> If software development was an RTS game, the "fog of war" should not exist
> for you, you must be aware of the whole map. While you can't **control** the
> entire map at all times, you can control your main sections && be very much
> aware of the others.

TODO: Insert RTS picture (C&C Generals or Starcraft)

You must be able to **juggle** with different technical areas: focus on one while
neglecting the other, then move to the next one etc... 

It's the same way with life: sometimes you need to put your entire focus on
business and neglect your health, then you tone down the amount of work on
the business and start training harder & eating healthier but then you maybe
neglect friends... etc. etc.

# SOFT SKILLS

## Act like a professional!

The tech industry became so relaxed that it's starting to kill productivity.
Technical skills still being in high demand can make tech workers feel way to
privileged, thinking they can do whatever they want, whenever they want. Lots
of businesses suffer because of this. Me, **I want to be a professional and
create value for the world**. If you want this as well - read on.

**Show up on time** and **be prepared**. **Start** and **end** your work day
**on time**, do not work on weekends or overtime, avoid burnout. Arrive at
meetings at least 1 min before the start time. Come prepared, don't ramble -
just get to the point. Give the most information in the least amount of words
possible. Be fast, learn how to speak effectively.

Be aware of who is in the "room" (virtual or physical). Don't spew technical
details if there's someone there who can't understand it. Keep the conversation
relevant to the people that are in the room.

Be **accountable** - when you say you'll do something, make sure that you get
it done. Keep a physical notebook around with a checklist of **TODO items**,
for me that's the easiest way to remember what I need to deliver.

Never promise or commit to something what you can't deliver. Don't let people
influence you into making unreal commitments.

Learn to work with your **tech team**. You must face the external world as a
unified entity. If one member of the team fails - everyone fails. Nobody cares
if one of your team members screwed up and that's the reason you couldn't
deliver - you all failed. If some of your team members are not pulling their
weight - let them go, terminate their contracts. There's no need for the rest of 
the team to pull other peoples weight and earn their salaires - it just creates
resentment & inefficiency. It's best to cut this out immediately - you can't be
afraid to hurt people's feelings.

Remember - the goal is to bring value to Humanity through the product that
you're creating. Everything else is a distraction.

> Go pro, or go home.

If it's in your interest to slack off & be sloppy - please change industries.
Better spend your time doing something that you really want to do. You're
definitely not going to work in my team.

There's A LOT to write on this topic and these are just the basics, but let's
move on. (I will probably write more about this in the future)


- Be a problem solver, you love HARD problems - no job is "underneath" you
  > Example: Annoying WebUI bug that nobody want's to spend time to fix, but it looks embarassing
  > Example: Bugs/problems that have dragged on for years

- Be enthusiastic

- Read quality books

- Study software architecture

- Study agile software methodologies (XP, SCRUM...)

- Focus on the Business

- Be aware of what your colleagues are working on

- Don't shy away from "Legacy" projects

A legacy project that needs fixing probably means that it has paying users,
which probably means that it offers some kind of value to people.

- Be open to change

